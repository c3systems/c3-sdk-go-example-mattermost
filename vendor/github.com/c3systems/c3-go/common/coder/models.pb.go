// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: models.proto

/*
	Package coder is a generated protocol buffer package.

	It is generated from these files:
		models.proto

	It has these top-level messages:
		MinedBlock
		MerkleTree
		MainchainBlock
		MinerSig
		StatechainBlock
		TxSig
		Transaction
		Diff
*/
package coder

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type MinedBlock struct {
	NextBlock           *MainchainBlock             `protobuf:"bytes,1,opt,name=nextBlock" json:"nextBlock,omitempty"`
	PreviousBlock       *MainchainBlock             `protobuf:"bytes,2,opt,name=previousBlock" json:"previousBlock,omitempty"`
	StatechainBlocksMap map[string]*StatechainBlock `protobuf:"bytes,3,rep,name=statechainBlocksMap" json:"statechainBlocksMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	TransactionsMap     map[string]*Transaction     `protobuf:"bytes,4,rep,name=transactionsMap" json:"transactionsMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	DiffsMap            map[string]*Diff            `protobuf:"bytes,5,rep,name=diffsMap" json:"diffsMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	MerkleTreesMap      map[string]*MerkleTree      `protobuf:"bytes,6,rep,name=merkleTreesMap" json:"merkleTreesMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MinedBlock) Reset()                    { *m = MinedBlock{} }
func (m *MinedBlock) String() string            { return proto.CompactTextString(m) }
func (*MinedBlock) ProtoMessage()               {}
func (*MinedBlock) Descriptor() ([]byte, []int) { return fileDescriptorModels, []int{0} }

func (m *MinedBlock) GetNextBlock() *MainchainBlock {
	if m != nil {
		return m.NextBlock
	}
	return nil
}

func (m *MinedBlock) GetPreviousBlock() *MainchainBlock {
	if m != nil {
		return m.PreviousBlock
	}
	return nil
}

func (m *MinedBlock) GetStatechainBlocksMap() map[string]*StatechainBlock {
	if m != nil {
		return m.StatechainBlocksMap
	}
	return nil
}

func (m *MinedBlock) GetTransactionsMap() map[string]*Transaction {
	if m != nil {
		return m.TransactionsMap
	}
	return nil
}

func (m *MinedBlock) GetDiffsMap() map[string]*Diff {
	if m != nil {
		return m.DiffsMap
	}
	return nil
}

func (m *MinedBlock) GetMerkleTreesMap() map[string]*MerkleTree {
	if m != nil {
		return m.MerkleTreesMap
	}
	return nil
}

type MerkleTree struct {
	MerkleTreeRootHash string   `protobuf:"bytes,1,opt,name=merkleTreeRootHash,proto3" json:"merkleTreeRootHash,omitempty"`
	Kind               string   `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Hashes             []string `protobuf:"bytes,3,rep,name=hashes" json:"hashes,omitempty"`
}

func (m *MerkleTree) Reset()                    { *m = MerkleTree{} }
func (m *MerkleTree) String() string            { return proto.CompactTextString(m) }
func (*MerkleTree) ProtoMessage()               {}
func (*MerkleTree) Descriptor() ([]byte, []int) { return fileDescriptorModels, []int{1} }

func (m *MerkleTree) GetMerkleTreeRootHash() string {
	if m != nil {
		return m.MerkleTreeRootHash
	}
	return ""
}

func (m *MerkleTree) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *MerkleTree) GetHashes() []string {
	if m != nil {
		return m.Hashes
	}
	return nil
}

type MainchainBlock struct {
	BlockHash             string    `protobuf:"bytes,1,opt,name=blockHash,proto3" json:"blockHash,omitempty"`
	BlockNumber           string    `protobuf:"bytes,2,opt,name=blockNumber,proto3" json:"blockNumber,omitempty"`
	BlockTime             string    `protobuf:"bytes,3,opt,name=blockTime,proto3" json:"blockTime,omitempty"`
	ImageHash             string    `protobuf:"bytes,4,opt,name=imageHash,proto3" json:"imageHash,omitempty"`
	StateBlocksMerkleHash string    `protobuf:"bytes,5,opt,name=stateBlocksMerkleHash,proto3" json:"stateBlocksMerkleHash,omitempty"`
	PrevBlockHash         string    `protobuf:"bytes,6,opt,name=prevBlockHash,proto3" json:"prevBlockHash,omitempty"`
	Nonce                 string    `protobuf:"bytes,7,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Difficulty            string    `protobuf:"bytes,8,opt,name=difficulty,proto3" json:"difficulty,omitempty"`
	MinerAddress          string    `protobuf:"bytes,9,opt,name=minerAddress,proto3" json:"minerAddress,omitempty"`
	MinerSig              *MinerSig `protobuf:"bytes,10,opt,name=minerSig" json:"minerSig,omitempty"`
}

func (m *MainchainBlock) Reset()                    { *m = MainchainBlock{} }
func (m *MainchainBlock) String() string            { return proto.CompactTextString(m) }
func (*MainchainBlock) ProtoMessage()               {}
func (*MainchainBlock) Descriptor() ([]byte, []int) { return fileDescriptorModels, []int{2} }

func (m *MainchainBlock) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *MainchainBlock) GetBlockNumber() string {
	if m != nil {
		return m.BlockNumber
	}
	return ""
}

func (m *MainchainBlock) GetBlockTime() string {
	if m != nil {
		return m.BlockTime
	}
	return ""
}

func (m *MainchainBlock) GetImageHash() string {
	if m != nil {
		return m.ImageHash
	}
	return ""
}

func (m *MainchainBlock) GetStateBlocksMerkleHash() string {
	if m != nil {
		return m.StateBlocksMerkleHash
	}
	return ""
}

func (m *MainchainBlock) GetPrevBlockHash() string {
	if m != nil {
		return m.PrevBlockHash
	}
	return ""
}

func (m *MainchainBlock) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *MainchainBlock) GetDifficulty() string {
	if m != nil {
		return m.Difficulty
	}
	return ""
}

func (m *MainchainBlock) GetMinerAddress() string {
	if m != nil {
		return m.MinerAddress
	}
	return ""
}

func (m *MainchainBlock) GetMinerSig() *MinerSig {
	if m != nil {
		return m.MinerSig
	}
	return nil
}

type MinerSig struct {
	R string `protobuf:"bytes,1,opt,name=r,proto3" json:"r,omitempty"`
	S string `protobuf:"bytes,2,opt,name=s,proto3" json:"s,omitempty"`
}

func (m *MinerSig) Reset()                    { *m = MinerSig{} }
func (m *MinerSig) String() string            { return proto.CompactTextString(m) }
func (*MinerSig) ProtoMessage()               {}
func (*MinerSig) Descriptor() ([]byte, []int) { return fileDescriptorModels, []int{3} }

func (m *MinerSig) GetR() string {
	if m != nil {
		return m.R
	}
	return ""
}

func (m *MinerSig) GetS() string {
	if m != nil {
		return m.S
	}
	return ""
}

type StatechainBlock struct {
	BlockHash         string `protobuf:"bytes,1,opt,name=blockHash,proto3" json:"blockHash,omitempty"`
	BlockNumber       string `protobuf:"bytes,2,opt,name=blockNumber,proto3" json:"blockNumber,omitempty"`
	BlockTime         string `protobuf:"bytes,3,opt,name=blockTime,proto3" json:"blockTime,omitempty"`
	ImageHash         string `protobuf:"bytes,4,opt,name=imageHash,proto3" json:"imageHash,omitempty"`
	TxHash            string `protobuf:"bytes,5,opt,name=txHash,proto3" json:"txHash,omitempty"`
	PrevBlockHash     string `protobuf:"bytes,6,opt,name=prevBlockHash,proto3" json:"prevBlockHash,omitempty"`
	StatePrevDiffHash string `protobuf:"bytes,7,opt,name=statePrevDiffHash,proto3" json:"statePrevDiffHash,omitempty"`
	StateCurrentHash  string `protobuf:"bytes,8,opt,name=stateCurrentHash,proto3" json:"stateCurrentHash,omitempty"`
}

func (m *StatechainBlock) Reset()                    { *m = StatechainBlock{} }
func (m *StatechainBlock) String() string            { return proto.CompactTextString(m) }
func (*StatechainBlock) ProtoMessage()               {}
func (*StatechainBlock) Descriptor() ([]byte, []int) { return fileDescriptorModels, []int{4} }

func (m *StatechainBlock) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *StatechainBlock) GetBlockNumber() string {
	if m != nil {
		return m.BlockNumber
	}
	return ""
}

func (m *StatechainBlock) GetBlockTime() string {
	if m != nil {
		return m.BlockTime
	}
	return ""
}

func (m *StatechainBlock) GetImageHash() string {
	if m != nil {
		return m.ImageHash
	}
	return ""
}

func (m *StatechainBlock) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *StatechainBlock) GetPrevBlockHash() string {
	if m != nil {
		return m.PrevBlockHash
	}
	return ""
}

func (m *StatechainBlock) GetStatePrevDiffHash() string {
	if m != nil {
		return m.StatePrevDiffHash
	}
	return ""
}

func (m *StatechainBlock) GetStateCurrentHash() string {
	if m != nil {
		return m.StateCurrentHash
	}
	return ""
}

type TxSig struct {
	R string `protobuf:"bytes,1,opt,name=r,proto3" json:"r,omitempty"`
	S string `protobuf:"bytes,2,opt,name=s,proto3" json:"s,omitempty"`
}

func (m *TxSig) Reset()                    { *m = TxSig{} }
func (m *TxSig) String() string            { return proto.CompactTextString(m) }
func (*TxSig) ProtoMessage()               {}
func (*TxSig) Descriptor() ([]byte, []int) { return fileDescriptorModels, []int{5} }

func (m *TxSig) GetR() string {
	if m != nil {
		return m.R
	}
	return ""
}

func (m *TxSig) GetS() string {
	if m != nil {
		return m.S
	}
	return ""
}

type Transaction struct {
	TxHash    string `protobuf:"bytes,1,opt,name=txHash,proto3" json:"txHash,omitempty"`
	ImageHash string `protobuf:"bytes,2,opt,name=imageHash,proto3" json:"imageHash,omitempty"`
	Method    string `protobuf:"bytes,3,opt,name=method,proto3" json:"method,omitempty"`
	// google.protobuf.Any payload = 4;
	Payload []byte `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	From    string `protobuf:"bytes,5,opt,name=from,proto3" json:"from,omitempty"`
	Sig     *TxSig `protobuf:"bytes,6,opt,name=sig" json:"sig,omitempty"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (m *Transaction) String() string            { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptorModels, []int{6} }

func (m *Transaction) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *Transaction) GetImageHash() string {
	if m != nil {
		return m.ImageHash
	}
	return ""
}

func (m *Transaction) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *Transaction) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Transaction) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Transaction) GetSig() *TxSig {
	if m != nil {
		return m.Sig
	}
	return nil
}

type Diff struct {
	DiffHash string `protobuf:"bytes,1,opt,name=diffHash,proto3" json:"diffHash,omitempty"`
	Data     string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Diff) Reset()                    { *m = Diff{} }
func (m *Diff) String() string            { return proto.CompactTextString(m) }
func (*Diff) ProtoMessage()               {}
func (*Diff) Descriptor() ([]byte, []int) { return fileDescriptorModels, []int{7} }

func (m *Diff) GetDiffHash() string {
	if m != nil {
		return m.DiffHash
	}
	return ""
}

func (m *Diff) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func init() {
	proto.RegisterType((*MinedBlock)(nil), "coder.MinedBlock")
	proto.RegisterType((*MerkleTree)(nil), "coder.MerkleTree")
	proto.RegisterType((*MainchainBlock)(nil), "coder.MainchainBlock")
	proto.RegisterType((*MinerSig)(nil), "coder.MinerSig")
	proto.RegisterType((*StatechainBlock)(nil), "coder.StatechainBlock")
	proto.RegisterType((*TxSig)(nil), "coder.TxSig")
	proto.RegisterType((*Transaction)(nil), "coder.Transaction")
	proto.RegisterType((*Diff)(nil), "coder.Diff")
}
func (m *MinedBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinedBlock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NextBlock != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.NextBlock.Size()))
		n1, err := m.NextBlock.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.PreviousBlock != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.PreviousBlock.Size()))
		n2, err := m.PreviousBlock.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.StatechainBlocksMap) > 0 {
		for k, _ := range m.StatechainBlocksMap {
			dAtA[i] = 0x1a
			i++
			v := m.StatechainBlocksMap[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovModels(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + msgSize
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintModels(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if len(m.TransactionsMap) > 0 {
		for k, _ := range m.TransactionsMap {
			dAtA[i] = 0x22
			i++
			v := m.TransactionsMap[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovModels(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + msgSize
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintModels(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if len(m.DiffsMap) > 0 {
		for k, _ := range m.DiffsMap {
			dAtA[i] = 0x2a
			i++
			v := m.DiffsMap[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovModels(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + msgSize
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintModels(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if len(m.MerkleTreesMap) > 0 {
		for k, _ := range m.MerkleTreesMap {
			dAtA[i] = 0x32
			i++
			v := m.MerkleTreesMap[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovModels(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + msgSize
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintModels(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	return i, nil
}

func (m *MerkleTree) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleTree) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MerkleTreeRootHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.MerkleTreeRootHash)))
		i += copy(dAtA[i:], m.MerkleTreeRootHash)
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Hashes) > 0 {
		for _, s := range m.Hashes {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MainchainBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MainchainBlock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BlockHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.BlockHash)))
		i += copy(dAtA[i:], m.BlockHash)
	}
	if len(m.BlockNumber) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.BlockNumber)))
		i += copy(dAtA[i:], m.BlockNumber)
	}
	if len(m.BlockTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.BlockTime)))
		i += copy(dAtA[i:], m.BlockTime)
	}
	if len(m.ImageHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.ImageHash)))
		i += copy(dAtA[i:], m.ImageHash)
	}
	if len(m.StateBlocksMerkleHash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.StateBlocksMerkleHash)))
		i += copy(dAtA[i:], m.StateBlocksMerkleHash)
	}
	if len(m.PrevBlockHash) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.PrevBlockHash)))
		i += copy(dAtA[i:], m.PrevBlockHash)
	}
	if len(m.Nonce) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Nonce)))
		i += copy(dAtA[i:], m.Nonce)
	}
	if len(m.Difficulty) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Difficulty)))
		i += copy(dAtA[i:], m.Difficulty)
	}
	if len(m.MinerAddress) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.MinerAddress)))
		i += copy(dAtA[i:], m.MinerAddress)
	}
	if m.MinerSig != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.MinerSig.Size()))
		n7, err := m.MinerSig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *MinerSig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinerSig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.R) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.R)))
		i += copy(dAtA[i:], m.R)
	}
	if len(m.S) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.S)))
		i += copy(dAtA[i:], m.S)
	}
	return i, nil
}

func (m *StatechainBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatechainBlock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BlockHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.BlockHash)))
		i += copy(dAtA[i:], m.BlockHash)
	}
	if len(m.BlockNumber) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.BlockNumber)))
		i += copy(dAtA[i:], m.BlockNumber)
	}
	if len(m.BlockTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.BlockTime)))
		i += copy(dAtA[i:], m.BlockTime)
	}
	if len(m.ImageHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.ImageHash)))
		i += copy(dAtA[i:], m.ImageHash)
	}
	if len(m.TxHash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.TxHash)))
		i += copy(dAtA[i:], m.TxHash)
	}
	if len(m.PrevBlockHash) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.PrevBlockHash)))
		i += copy(dAtA[i:], m.PrevBlockHash)
	}
	if len(m.StatePrevDiffHash) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.StatePrevDiffHash)))
		i += copy(dAtA[i:], m.StatePrevDiffHash)
	}
	if len(m.StateCurrentHash) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.StateCurrentHash)))
		i += copy(dAtA[i:], m.StateCurrentHash)
	}
	return i, nil
}

func (m *TxSig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxSig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.R) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.R)))
		i += copy(dAtA[i:], m.R)
	}
	if len(m.S) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.S)))
		i += copy(dAtA[i:], m.S)
	}
	return i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.TxHash)))
		i += copy(dAtA[i:], m.TxHash)
	}
	if len(m.ImageHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.ImageHash)))
		i += copy(dAtA[i:], m.ImageHash)
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if m.Sig != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Sig.Size()))
		n8, err := m.Sig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *Diff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Diff) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DiffHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.DiffHash)))
		i += copy(dAtA[i:], m.DiffHash)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MinedBlock) Size() (n int) {
	var l int
	_ = l
	if m.NextBlock != nil {
		l = m.NextBlock.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.PreviousBlock != nil {
		l = m.PreviousBlock.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.StatechainBlocksMap) > 0 {
		for k, v := range m.StatechainBlocksMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovModels(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovModels(uint64(mapEntrySize))
		}
	}
	if len(m.TransactionsMap) > 0 {
		for k, v := range m.TransactionsMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovModels(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovModels(uint64(mapEntrySize))
		}
	}
	if len(m.DiffsMap) > 0 {
		for k, v := range m.DiffsMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovModels(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovModels(uint64(mapEntrySize))
		}
	}
	if len(m.MerkleTreesMap) > 0 {
		for k, v := range m.MerkleTreesMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovModels(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovModels(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MerkleTree) Size() (n int) {
	var l int
	_ = l
	l = len(m.MerkleTreeRootHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Hashes) > 0 {
		for _, s := range m.Hashes {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *MainchainBlock) Size() (n int) {
	var l int
	_ = l
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.BlockNumber)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.BlockTime)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.ImageHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.StateBlocksMerkleHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.PrevBlockHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Difficulty)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.MinerAddress)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.MinerSig != nil {
		l = m.MinerSig.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *MinerSig) Size() (n int) {
	var l int
	_ = l
	l = len(m.R)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *StatechainBlock) Size() (n int) {
	var l int
	_ = l
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.BlockNumber)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.BlockTime)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.ImageHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.PrevBlockHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.StatePrevDiffHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.StateCurrentHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *TxSig) Size() (n int) {
	var l int
	_ = l
	l = len(m.R)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Transaction) Size() (n int) {
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.ImageHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Sig != nil {
		l = m.Sig.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Diff) Size() (n int) {
	var l int
	_ = l
	l = len(m.DiffHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func sovModels(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MinedBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinedBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinedBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextBlock == nil {
				m.NextBlock = &MainchainBlock{}
			}
			if err := m.NextBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousBlock == nil {
				m.PreviousBlock = &MainchainBlock{}
			}
			if err := m.PreviousBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatechainBlocksMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatechainBlocksMap == nil {
				m.StatechainBlocksMap = make(map[string]*StatechainBlock)
			}
			var mapkey string
			var mapvalue *StatechainBlock
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthModels
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthModels
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StatechainBlock{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StatechainBlocksMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionsMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionsMap == nil {
				m.TransactionsMap = make(map[string]*Transaction)
			}
			var mapkey string
			var mapvalue *Transaction
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthModels
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthModels
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Transaction{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TransactionsMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiffsMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiffsMap == nil {
				m.DiffsMap = make(map[string]*Diff)
			}
			var mapkey string
			var mapvalue *Diff
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthModels
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthModels
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Diff{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DiffsMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleTreesMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MerkleTreesMap == nil {
				m.MerkleTreesMap = make(map[string]*MerkleTree)
			}
			var mapkey string
			var mapvalue *MerkleTree
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthModels
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthModels
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MerkleTree{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MerkleTreesMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleTree) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleTree: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleTree: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleTreeRootHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleTreeRootHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hashes = append(m.Hashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MainchainBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MainchainBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MainchainBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateBlocksMerkleHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateBlocksMerkleHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevBlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevBlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Difficulty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Difficulty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinerSig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinerSig == nil {
				m.MinerSig = &MinerSig{}
			}
			if err := m.MinerSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinerSig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinerSig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinerSig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.R = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatechainBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatechainBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatechainBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevBlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevBlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatePrevDiffHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatePrevDiffHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateCurrentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateCurrentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxSig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxSig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxSig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.R = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sig == nil {
				m.Sig = &TxSig{}
			}
			if err := m.Sig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Diff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Diff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Diff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiffHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiffHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModels
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModels(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModels = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("models.proto", fileDescriptorModels) }

var fileDescriptorModels = []byte{
	// 710 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x95, 0x4b, 0x6e, 0xdb, 0x48,
	0x10, 0x86, 0x41, 0xbd, 0x2c, 0x95, 0xe4, 0x57, 0xf9, 0x01, 0xc2, 0x18, 0x68, 0x3c, 0x9c, 0x19,
	0xc7, 0x70, 0x0c, 0x2d, 0xec, 0x20, 0x08, 0xe2, 0x55, 0x9c, 0x04, 0xf0, 0x46, 0x81, 0x41, 0x0b,
	0x59, 0x05, 0x01, 0xda, 0x62, 0xdb, 0x22, 0x24, 0xb2, 0x85, 0x6e, 0xca, 0xb0, 0xae, 0x91, 0x3b,
	0x64, 0x91, 0x9b, 0x64, 0x99, 0x23, 0x04, 0xbe, 0x40, 0xae, 0x10, 0x74, 0xb1, 0x45, 0x35, 0x25,
	0xe6, 0xb1, 0xcb, 0xae, 0xab, 0xea, 0xaf, 0x8f, 0xea, 0xbf, 0x58, 0x14, 0xb4, 0x22, 0x11, 0xf0,
	0x91, 0xea, 0x8c, 0xa5, 0x48, 0x04, 0x56, 0xfb, 0x22, 0xe0, 0xd2, 0xfb, 0x50, 0x03, 0xe8, 0x86,
	0x31, 0x0f, 0xce, 0x47, 0xa2, 0x3f, 0xc4, 0x53, 0x68, 0xc4, 0xfc, 0x3e, 0xa1, 0xc0, 0x75, 0xf6,
	0x9d, 0xc3, 0xe6, 0xc9, 0x4e, 0x87, 0x94, 0x9d, 0x2e, 0x0b, 0xe3, 0xfe, 0x80, 0x85, 0x31, 0x15,
	0xfd, 0xb9, 0x0e, 0xcf, 0x60, 0x75, 0x2c, 0xf9, 0x5d, 0x28, 0x26, 0x2a, 0x6d, 0x2c, 0xfd, 0xac,
	0x31, 0xaf, 0xc5, 0x77, 0xb0, 0xa5, 0x12, 0x96, 0xf0, 0xb9, 0x42, 0x75, 0xd9, 0xd8, 0x2d, 0xef,
	0x97, 0x0f, 0x9b, 0x27, 0x47, 0x33, 0x44, 0xf6, 0x0b, 0x3b, 0x57, 0xcb, 0xe2, 0xd7, 0x71, 0x22,
	0xa7, 0x7e, 0x11, 0x06, 0x2f, 0x61, 0x3d, 0x91, 0x2c, 0x56, 0xac, 0x9f, 0x84, 0x22, 0x26, 0x72,
	0x85, 0xc8, 0x07, 0xcb, 0xe4, 0x5e, 0x5e, 0x98, 0x52, 0x17, 0xdb, 0xf1, 0x0c, 0xea, 0x41, 0x78,
	0x73, 0x43, 0xa8, 0x2a, 0xa1, 0xfe, 0x5e, 0x46, 0xbd, 0x32, 0x8a, 0x94, 0x91, 0x35, 0x60, 0x17,
	0xd6, 0x22, 0x2e, 0x87, 0x23, 0xde, 0x93, 0x9c, 0x13, 0xa2, 0x46, 0x88, 0xff, 0x97, 0x11, 0xdd,
	0x9c, 0x2e, 0x05, 0x2d, 0x34, 0xef, 0xbd, 0x07, 0xf7, 0x47, 0x76, 0xe0, 0x06, 0x94, 0x87, 0x7c,
	0x4a, 0x33, 0x6c, 0xf8, 0xfa, 0x88, 0xc7, 0x50, 0xbd, 0x63, 0xa3, 0x09, 0x37, 0xe3, 0xd9, 0x35,
	0xcf, 0x5c, 0x20, 0xf8, 0xa9, 0xe8, 0x79, 0xe9, 0x99, 0xb3, 0xf7, 0x16, 0xb6, 0x8b, 0x4c, 0x29,
	0x60, 0x1f, 0xe6, 0xd9, 0x68, 0xd8, 0x56, 0xb7, 0xcd, 0xbd, 0x80, 0xd5, 0x9c, 0x43, 0x05, 0xc0,
	0x7f, 0xf2, 0xc0, 0xa6, 0x01, 0xea, 0x36, 0x9b, 0xd4, 0x83, 0xad, 0x02, 0xa3, 0x0a, 0x78, 0x8f,
	0xf2, 0xbc, 0xcd, 0x99, 0xe1, 0x59, 0xb3, 0x45, 0xf5, 0x06, 0x00, 0xf3, 0x02, 0x76, 0x00, 0xe7,
	0xbe, 0xfb, 0x42, 0x24, 0x17, 0x4c, 0x0d, 0x0c, 0xbb, 0xa0, 0x82, 0x08, 0x95, 0x61, 0x18, 0x07,
	0xf4, 0xa4, 0x86, 0x4f, 0x67, 0xdc, 0x85, 0xda, 0x80, 0xa9, 0x01, 0x57, 0xf4, 0x62, 0x37, 0x7c,
	0x13, 0x79, 0xdf, 0x4a, 0xb0, 0x96, 0xdf, 0x0f, 0xfc, 0x0b, 0x1a, 0xd7, 0xfa, 0x60, 0x3d, 0x65,
	0x9e, 0xc0, 0x7d, 0x68, 0x52, 0xf0, 0x66, 0x12, 0x5d, 0x73, 0x69, 0x9e, 0x61, 0xa7, 0xb2, 0xfe,
	0x5e, 0x18, 0x71, 0xb7, 0x6c, 0xf5, 0xeb, 0x84, 0xae, 0x86, 0x11, 0xbb, 0xe5, 0x44, 0xaf, 0xa4,
	0xd5, 0x2c, 0x81, 0x4f, 0x60, 0x87, 0xb6, 0xc8, 0xbc, 0x4b, 0x74, 0x37, 0x52, 0x56, 0x49, 0x59,
	0x5c, 0xc4, 0xff, 0xd2, 0xfd, 0x3f, 0xcf, 0x7e, 0x75, 0x8d, 0xd4, 0xf9, 0x24, 0x6e, 0x43, 0x35,
	0x16, 0x71, 0x9f, 0xbb, 0x2b, 0x54, 0x4d, 0x03, 0x6c, 0x03, 0xe8, 0xed, 0x08, 0xfb, 0x93, 0x51,
	0x32, 0x75, 0xeb, 0x54, 0xb2, 0x32, 0xe8, 0x41, 0x2b, 0x0a, 0x63, 0x2e, 0x5f, 0x04, 0x81, 0xe4,
	0x4a, 0xb9, 0x0d, 0x52, 0xe4, 0x72, 0xf8, 0x18, 0xea, 0x14, 0x5f, 0x85, 0xb7, 0x2e, 0xd0, 0x78,
	0xd7, 0xad, 0x7d, 0xd2, 0x69, 0x3f, 0x13, 0x78, 0x07, 0x50, 0x9f, 0x65, 0xb1, 0x05, 0x8e, 0x34,
	0x16, 0x3b, 0x52, 0x47, 0xca, 0x18, 0xea, 0x28, 0xef, 0x63, 0x09, 0xd6, 0x17, 0x56, 0xe3, 0x8f,
	0x8e, 0x66, 0x17, 0x6a, 0xc9, 0xbd, 0x35, 0x0b, 0x13, 0xfd, 0xa6, 0xf9, 0xc7, 0xb0, 0x49, 0xb3,
	0xbb, 0x94, 0xfc, 0x4e, 0xef, 0x10, 0x29, 0xd3, 0x41, 0x2c, 0x17, 0xf0, 0x08, 0x36, 0x28, 0xf9,
	0x72, 0x22, 0x25, 0x8f, 0xd3, 0xf7, 0x3d, 0x1d, 0xcd, 0x52, 0xde, 0xfb, 0x17, 0xaa, 0xbd, 0xfb,
	0x5f, 0x99, 0xf9, 0xc9, 0x81, 0xa6, 0xf5, 0x2d, 0xb0, 0x2e, 0xe3, 0xe4, 0x2e, 0x93, 0xb3, 0xa0,
	0x54, 0x60, 0x41, 0xc4, 0x93, 0x81, 0x08, 0x8c, 0x77, 0x26, 0x42, 0x17, 0x56, 0xc6, 0x6c, 0x3a,
	0x12, 0x2c, 0x20, 0xdb, 0x5a, 0xfe, 0x2c, 0xd4, 0xab, 0x78, 0x23, 0x45, 0x64, 0x2c, 0xa3, 0x33,
	0xb6, 0xa1, 0xac, 0xc2, 0x5b, 0xb2, 0xa9, 0x79, 0xd2, 0x9a, 0x7d, 0xa8, 0xf4, 0x15, 0x7c, 0x5d,
	0xf0, 0x9e, 0x42, 0x45, 0x1b, 0x81, 0x7b, 0xe9, 0x87, 0xde, 0xfa, 0x95, 0x59, 0xac, 0xb9, 0x01,
	0x4b, 0xd8, 0x6c, 0xc5, 0xf5, 0xf9, 0xbc, 0xf5, 0xf9, 0xa1, 0xed, 0x7c, 0x79, 0x68, 0x3b, 0x5f,
	0x1f, 0xda, 0xce, 0x75, 0x8d, 0xfe, 0x65, 0x4f, 0xbf, 0x07, 0x00, 0x00, 0xff, 0xff, 0x5f, 0xf7,
	0x2a, 0xf4, 0x75, 0x07, 0x00, 0x00,
}
